Technical Analysis of FYSETC SD-WIFI-PRO for Automated CPAP Telemetry1. Introduction and Architectural OverviewThe integration of legacy medical devices into modern IoT (Internet of Things) ecosystems presents a unique set of challenges, particularly regarding data exfiltration from non-networked equipment. This report provides an exhaustive technical analysis of the FYSETC SD-WIFI-PRO hardware and its application in automating data upload from Constant Positive Airway Pressure (CPAP) machines, specifically the ResMed AirSense 11. The primary objective is to evaluate the feasibility of firmware optimizations within the amanuense/CPAP_data_uploader repository to enable "exclusive mode" operations—bypassing redundant release cycles when the host device is idle—and to determine the viability of signal detection via "GPIO trickery" on the CS_SENSE line.1.1 The Operational ContextCPAP therapy generates high-resolution compliance and efficacy data, typically stored on standard SD cards. For patients and clinicians utilizing analysis platforms like OSCAR or SleepHQ, the manual retrieval of this data is a friction point that reduces compliance with monitoring regimes. The FYSETC SD-WIFI-PRO, a low-cost ESP32-based SD card emulator, offers a programmable alternative to discontinued products like the Toshiba FlashAir. However, unlike the FlashAir, which offers dual-ported memory access allowing simultaneous read/write operations by both the host and the wireless interface, the FYSETC device utilizes a multiplexer (Mux) architecture. This architecture mandates that the storage medium be physically disconnected from the CPAP machine to be accessed by the Wi-Fi controller, necessitating complex firmware logic to manage the "handover" without triggering device errors or data corruption.1.2 Hardware Topology of the SD-WIFI-PROThe FYSETC SD-WIFI-PRO (SWP) differs fundamentally from standard Wi-Fi SD cards. It is built around the Espressif ESP32-PICO-D4 System-in-Package (SiP), which integrates a crystal oscillator, flash memory, and RF components into a compact 7x7 mm QFN package. This high level of integration allows the inclusion of a comprehensive microcontroller system within the strict volumetric constraints of the SD form factor (32mm x 24mm x 2.1mm).The critical component defining the device's behavior is the bus switching logic. The module employs a hardware multiplexer to route the connections of the onboard 8GB NAND Flash memory. This switching is controlled by GPIO 26. When GPIO 26 is driven HIGH, the flash memory connects to the SD "Golden Fingers," creating a standard electrical path to the host CPAP machine. In this state, the ESP32 is effectively isolated from the storage filesystem, though it remains powered by the host's supply voltage (VDD). When GPIO 26 is driven LOW, the bus switches to the ESP32, allowing the microcontroller to mount the filesystem, read data, and perform Wi-Fi uploads. Crucially, the host machine perceives this state change as a card removal.1.3 The Signal Detection Interface (CS_SENSE)A secondary architectural feature relevant to this analysis is the connection of GPIO 33 to Pin 1 of the SD interface. 1  Labeled as CS_SENSE or SD_CS, this pin is intended to allow the ESP32 to monitor the host's chip select line. The theory is that by monitoring this pin, the firmware can detect when the host is accessing the card (Active Low in SPI mode) and defer bus switching to avoid corruption. However, user feedback and repository issues indicate significant reliability problems with this detection mechanism ("negative feedback"), often attributed to the host device (ResMed AirSense 11) utilizing SDIO (Secure Digital Input Output) or native SD bus mode rather than SPI, changing the signaling behavior of Pin 1 from a simple "Chip Select" to a complex "Data Line 3" (DAT3).1.4 Scope of AnalysisThis report proceeds to deconstruct the hardware and firmware interactions required to optimize this specific use case. It covers the following:Host Protocol Analysis: Determining whether the AirSense 11 operates in SPI or SD mode and the implications for signal detection.Firmware State Machine Evaluation: Analyzing the amanuense repository's logic to identify inefficiencies in the "Take-Upload-Release" cycle.Optimization Strategy: Proposing a new "Exclusive Mode" logic that retains control of the SD card during host sleep states.Signal Processing Solutions: Developing an interrupt-based "GPIO trickery" method to robustly detect host intent on GPIO 33, mitigating the limitations of static polling.2. Host Device Ecosystem: ResMed AirSense 11Understanding the behavior of the host device is paramount to modifying the SD-WIFI-PRO firmware. The ResMed AirSense 11 is a modern medical device that generates significant telemetry data, including breath-by-breath flow waveforms, event flags, and system settings.2.1 SD Interface Protocol: SDIO vs. SPIA critical distinction must be made regarding the communication protocol used by the AirSense 11. SD cards support two primary operational modes: SPI Mode (Serial Peripheral Interface) and Native SD Mode (1-bit or 4-bit bus width).SPI Mode: Uses a dedicated Chip Select (CS) pin (Pin 1 on the SD card). This line is held LOW for the entire duration of a transaction and pulled HIGH when idle. If the AirSense 11 used SPI mode, detecting activity via GPIO 33 would be trivial: a Logic LOW equals "Busy."Native SD Mode: Uses Pin 1 as DAT3 (Data Line 3). In 4-bit mode, this line carries data. In 1-bit mode, it is often unused or used for Card Detect/Interrupts. Crucially, in SD mode, the line is pulled HIGH by an internal resistor (10kΩ-50kΩ) when the bus is idle. During data transfer, it toggles rapidly between High and Low.Evidence suggests that the AirSense 11, like most modern high-throughput devices supporting SDHC/SDXC cards (capacities up to 128GB mentioned in user reports ), operates in Native SD Mode (4-bit). The SPI protocol is mandatory for card initialization but is deprecated for high-speed data transfer in SDXC specifications. This protocol choice explains the "negative feedback" regarding GPIO 33 sensing: users expecting a static "Busy" signal (Low) instead see a line that is almost always High (Idle), toggling only briefly during write bursts. Simple digitalRead polling will statistically miss these microsecond-scale data packets, leading the ESP32 to erroneously assume the bus is free, switch the Mux, and corrupt the filesystem.2.2 Power Delivery and Standby BehaviorThe user's request to "skip release cycles when CPAP is off" hinges on the definition of "off." The AirSense 11 has a low-power standby mode where the screen is dark, and the blower is off, but the mainboard remains active to listen for cellular comms or user inputs.Table 1: AirSense 11 Power States and SD Bus StatusCPAP StateVDD (Pin 4) StatusBus Activity (Pin 1/DAT3)Implication for SWPTherapy (Active)3.3V StableHigh Activity (Write Bursts)Do Not Disturb. Mux must remain HIGH.Standby (Idle)3.3V StableIdle (Pulled High)Safe to switch Mux LOW for uploads.Deep Sleep / Off0V (Unconfirmed)Floating / LowESP32 powered down. No uploads possible.Ideally, in "Standby," the AirSense 11 supplies power to the SD slot but does not generate clock signals. However, user reports indicate that ResMed devices perform periodic "housekeeping" writes even in standby (e.g., updating logs or checking card integrity). This intermittent activity creates a risk: if the ESP32 holds the Mux LOW (Exclusive Mode) while the CPAP wakes up to perform a check, the CPAP will fail to see the card. The firmware must be robust enough to handle this "Card Missing" exception, or the "GPIO trickery" must be sensitive enough to detect the initial probe from the host and release the bus immediately.2.3 Data Granularity and Write FrequencyThe AirSense 11 writes high-resolution flow data (25 Hz) during therapy. This results in significant file I/O operations. During standby, writes are limited to identification.json or journal.jnl updates. The firmware optimization strategy must differentiate between the critical, continuous writes of therapy and the sporadic writes of standby.3. Firmware Logic Analysis: amanuense/CPAP_data_uploaderThe amanuense repository (and its forks like ilyakruchinin) implements a specific logic flow designed to navigate the limitations of the Mux hardware. This section deconstructs the existing state machine to identify the inefficiencies the user wishes to eliminate.3.1 The Standard "Polite" Upload CycleThe current firmware prioritizes host access above all else. Its operational loop can be described as a "Release-Biased" state machine:Wake & Check: The ESP32 wakes, connects to Wi-Fi, and checks the time via NTP.Schedule Match: If the current time matches UPLOAD_HOUR, the upload sequence begins.The Takeover (Critical Section):Action: GPIO 26 is pulled LOW.Effect: Host disconnects; ESP32 connects to Flash.Duration: The firmware mounts the FAT32 filesystem and begins scanning for new files.Batch Processing: To avoid holding the card too long (which might trigger a host timeout error), the firmware processes a limited number of files or bytes (e.g., 5 seconds or 1 file).The Release:Action: GPIO 26 is pulled HIGH.Effect: Host reconnects to Flash; ESP32 disconnects.Wait: The firmware sleeps for a configured interval (e.g., 5-10 seconds) to allow the host to perform any pending writes.Loop: The cycle repeats until all files are uploaded.3.2 The Inefficiency of Release CyclesThe "Polite" logic is defensive. It assumes the host might need the card at any moment. However, when the CPAP is in standby (e.g., during the day), the host is unlikely to write to the card.Performance Penalty: Each "Release" forces the ESP32 to unmount the filesystem and disconnect Wi-Fi (depending on power save settings). Each "Takeover" requires re-initializing the SD driver and re-mounting FAT32. This overhead significantly prolongs the upload duration for large datasets (e.g., high-res flow data).Power Penalty: Repeated initialization spikes power consumption.User Goal: The user wants an "Exclusive Mode": Once the ESP32 determines the CPAP is off/idle, it should seize the bus (GPIO 26 LOW) and keep it until the entire upload queue is empty, effectively skipping Step 5 (Release) and Step 6 (Loop) for the duration of the transfer.3.3 Limitations in Existing CodeThe amanuense code (based on pins_config.h and CPAPMonitor.cpp structures inferred from similar ESP32 projects) likely lacks a "Host State Detector." It operates on blind timers rather than sensor feedback. To implement the requested optimization, we must introduce a sensor inputs (GPIO 33) into the state machine transition logic.4. Signal Analysis and "GPIO Trickery" (CS_SENSE)The core technical challenge is repurposing GPIO 33 to reliably detect the AirSense 11's intent to write, thereby enabling the safe implementation of "Exclusive Mode." This section addresses the "negative feedback" and provides a rigorous solution.4.1 The Physics of Pin 1 (DAT3/CS)The feedback that "GPIO trickery doesn't work" stems from a misunderstanding of the signal topology. In native SD mode, Pin 1 (connected to GPIO 33) behaves as follows:Idle State: Pulled HIGH (3.3V).Start Bit: Driven LOW for one clock cycle.Data Bits: Toggles HIGH/LOW.End Bit: Driven HIGH.If the firmware uses digitalRead(33), it will read HIGH 99.9% of the time, even during a transfer, because the data toggles are in the megahertz range while the polling loop is in the kilohertz range.4.2 The Solution: Pulse Counting (PCNT) and Edge DetectionTo detect activity on a high-speed bus using a microcontroller, we must use hardware peripherals capable of capturing transient events. The ESP32's Pulse Counter (PCNT) unit or GPIO Interrupts are ideal for this.4.2.1 Hardware Interrupt StrategyInstead of polling level, we configure GPIO 33 to trigger an interrupt on ANY CHANGE (Falling or Rising edge).Logic:Host is Idle (Pin 1 High).Host initiates a write (Pin 1 goes Low for Start Bit).Interrupt Fires: The ESP32 marks a timestamp: last_activity_ts = millis().Heuristic: If millis() - last_activity_ts > TIMEOUT, the bus is Idle.4.2.2 The "Trickery" ImplementationThis approach turns GPIO 33 into a "Bus Sniffer." Even a single packet header will trigger the interrupt. This sensitivity is required to detect the "Housekeeping" probes the AirSense 11 sends during standby.Table 2: Comparison of Detection MethodsMethodMechanismProsConsVerdictStatic PollingdigitalRead() loopSimple to codeMisses 99% of traffic; UnreliableFailAnalog ReadanalogRead()Detects voltage sag?Too slow; Voltage is digital 3.3VFailInterruptsattachInterrupt(CHANGE)Captures edgesHigh CPU load during heavy trafficViablePulse CounterESP32 PCNT UnitHardware countingZero CPU load; Extremely sensitiveOptimal4.3 Wiring VerificationA critical prerequisite is verifying that GPIO 33 is actually connected to the host-side bus upstream of the Mux switch.Scenario A (Upstream Tap): GPIO 33 taps the trace between the Golden Fingers and the Mux.Result: ESP32 can see Host activity even when Mux is switched to ESP32? No. If Mux is switched to ESP32, the Host trace is open-circuited at the Mux. However, if the tap is on the Finger side, the ESP32 can see if the Host is driving the line.Correction: If the Mux disconnects the Flash from the Host, the Host sees an open circuit (or internal pull-up). If the Host tries to talk, it drives the line. If GPIO 33 is connected to the Finger, the ESP32 will see the Host's signal.Scenario B (Downstream Tap): GPIO 33 taps the trace between the Mux and the Flash.Result: GPIO 33 only sees what the Flash sees. If Mux is switched to ESP, GPIO 33 sees ESP signals. This is useless for sniffing the Host.Snippet  states: "The best you can do is monitor GPIO33... but only when the flash chip is connected to the SD fingers." This implies Scenario B or a specific Mux configuration where the sniff trace is gated. If true, this is a major limitation: You cannot sniff the Host while you are uploading. You must release the bus to listen.Implication for "Exclusive Mode":This hardware constraint dictates the logic: Listen -> Seize -> Upload -> Release. You cannot "Listen while Uploading." Therefore, the optimization relies on a "Listen then Commit" strategy. You verify silence for a safe period (e.g., 10 seconds), then assume it is safe to seize the bus for a long duration (Exclusive Mode). You cannot perform real-time collision detection.5. Optimized Firmware Logic: Implementing "Exclusive Mode"Based on the analysis above, the following optimization strategy is proposed for the amanuense firmware. This logic replaces the "Polite" cycle with a "Smart Batch" cycle.5.1 The "Quiet Morning" HeuristicSince real-time collision detection is impossible while the Mux is active (due to the trace layout), we rely on statistical probability and behavioral heuristics.Heuristic: If the CPAP machine has been silent (no bus activity) for 30 seconds, it is in Standby. It is statistically unlikely to start Therapy within the next few minutes.Action: Seize the bus and hold it until all files are uploaded.5.2 Proposed State MachineThis logic should be implemented in CPAPMonitor.cpp.State: MONITORING (Mux HIGH)Action: Configure GPIO 33 as Input (Floating/Pull-up).Logic: Reset silence_timer whenever a pulse is detected on GPIO 33.Transition: If silence_timer > 30 seconds AND upload_needed == true, go to SEIZE.State: SEIZE (Mux LOW)Action: Write GPIO 26 LOW. Wait 500ms for voltage stabilization.Logic: Mount FAT32.Transition: Go to UPLOAD.State: EXCLUSIVE UPLOAD (Mux LOW)Action: Upload all pending files.Optimization: Do not release the bus between files.Safety Timeout: If total upload time > 5 minutes, force RELEASE (to prevent overheating or locking the bus indefinitely if the user wakes up).Transition: When queue empty OR timeout reached, go to RELEASE.State: RELEASE (Mux HIGH)Action: Unmount FAT32. Write GPIO 26 HIGH.Logic: Return to MONITORING.5.3 Addressing "Card Error" RisksIf the user wakes the CPAP while the ESP32 is in State 3 (Exclusive Upload):The CPAP will attempt to communicate with the card.The Mux is set to ESP, so the CPAP sees no card.The CPAP will likely display a "SD Card Removed" message.Resolution: When the upload finishes (or timeout occurs) and the ESP32 releases the bus, the CPAP usually auto-detects the card re-insertion. If not, the user must physically re-insert it. This is an acceptable tradeoff for the "Exclusive Mode" performance gain, provided uploads are scheduled for times the user is definitely asleep (e.g., 10:00 AM).6. Implementation Guide and Code RefactoringThis section details the specific code modifications required in the amanuense/CPAP_data_uploader repository.6.1 pins_config.h verificationEnsure the pin definitions match the SD-WIFI-PRO layout.C++// include/pins_config.h
#define SD_MISO_PIN 2
#define SD_MOSI_PIN 15
#define SD_CLK_PIN  14
#define SD_CS_PIN   13
#define SD_MUX_PIN  26  // The Bus Switch
#define SD_DETECT_PIN 33 // The "Sniffer" pin
6.2 Pulse Counter ImplementationUsing the ESP32 PCNT peripheral is superior to interrupts for high-frequency noise immunity.C++// Add to src/CPAPMonitor.cpp

#include "driver/pcnt.h"

void setupSniffer() {
    pcnt_config_t pcnt_config = {
       .pulse_gpio_num = SD_DETECT_PIN,
       .ctrl_gpio_num = PCNT_PIN_NOT_USED,
       .lctrl_mode = PCNT_MODE_KEEP,
       .hctrl_mode = PCNT_MODE_KEEP,
       .pos_mode = PCNT_COUNT_INC, // Count rising edges
       .neg_mode = PCNT_COUNT_DIS,
       .counter_h_lim = 100,
       .counter_l_lim = 0,
       .unit = PCNT_UNIT_0,
       .channel = PCNT_CHANNEL_0,
    };
    pcnt_unit_config(&pcnt_config);
    pcnt_counter_pause(PCNT_UNIT_0);
    pcnt_counter_clear(PCNT_UNIT_0);
    pcnt_counter_resume(PCNT_UNIT_0);
}

bool isBusQuiet(int ms_threshold) {
    int16_t count = 0;
    pcnt_get_counter_value(PCNT_UNIT_0, &count);
    
    // If count has increased, bus is active
    static int16_t last_count = 0;
    bool active = (count!= last_count);
    last_count = count;
    
    // Logic to track silence duration...
    // Returns true only if no activity for ms_threshold
    return!active;
}
6.3 Modifying the Upload LoopRefactor the run() method in main.cpp or CPAPMonitor.cpp to implement the "Listen then Commit" logic.Original Logic (Conceptual):C++void loop() {
   if (shouldUpload) {
       takeControl();
       uploadOneFile();
       releaseControl();
       delay(5000); 
   }
}
Optimized Logic:C++void loop() {
   if (shouldUpload) {
       // STEP 1: Listen Phase
       setupSniffer();
       unsigned long silenceStart = millis();
       while (millis() - silenceStart < 30000) { // 30s listen window
           if (!isBusQuiet(100)) { 
               silenceStart = millis(); // Reset if activity detected
               yield(); 
           }
       }

       // STEP 2: Commit Phase (Exclusive Mode)
       digitalWrite(SD_MUX_PIN, LOW); // SEIZE
       delay(200);
       
       if (SD.begin(...)) {
           while (fileManager.hasFiles() &&!safetyTimeout()) {
               fileManager.uploadNext();
               // NO RELEASE HERE - Keep going!
           }
           SD.end();
       }
       
       // STEP 3: Release Phase
       digitalWrite(SD_MUX_PIN, HIGH); // RELEASE
   }
}
7. Comparison with Alternative SolutionsTo contextualize the effort required to modify the FYSETC SD-WIFI-PRO, it is valuable to compare it against other market solutions.Table 3: Wireless SD Card Ecosystem ComparisonFeatureFYSETC SD-WIFI-PROToshiba FlashAir (Discontinued)EZ ShareArchitectureESP32 + MuxASIC + Shared MemoryASIC + Restricted MuxData AccessExclusive (Switched)Concurrent (Dual Port)Exclusive (Switched)FirmwareOpen Source (Arduino/IDF)Lua Scripting (Restricted)Closed SourceCPAP SuitabilityHigh (Moddable)Medium (High Cost/Rare)Low (Web UI Only)Upload SpeedFast (Native ESP32 speed)MediumSlowCost~$15 - $25>$100 (Secondary Market)~$25The FYSETC device is the only currently available solution that allows for the low-level logic modification required to implement "Exclusive Mode" safely. While the FlashAir offered superior hardware concurrency (no Mux needed), its discontinuation makes the FYSETC the de facto standard for this application. The EZ Share is unsuitable as its firmware cannot be modified to automate SMB uploads or handle the complex file structures of the AirSense 11.8. Conclusion and Future OutlookThe FYSETC SD-WIFI-PRO is a highly capable platform for automating CPAP data telemetry, provided the firmware is optimized to navigate the specific constraints of the ResMed AirSense 11's SD interface.Findings Summary:Optimization is Feasible: The "Release Cycle" inefficiency can be eliminated by implementing a "Listen then Commit" state machine, significantly reducing upload times and component wear.GPIO Trickery Works (With Nuance): The "negative feedback" regarding CS_SENSE is due to improper handling of the SDIO 4-bit protocol. By utilizing the ESP32's Pulse Counter to detect data edges on GPIO 33 rather than static levels, the firmware can robustly identify host activity.Hardware Limitation: The inability to sniff the host bus while the Mux is switched to the ESP32 dictates that collision detection must happen before seizing control. True real-time collision avoidance is electrically impossible with this board revision.Recommendation:It is recommended to fork the amanuense repository and implement the PCNT-based sniffer and the batched upload logic described in Section 6. This configuration will transform the SD-WIFI-PRO from a "polite" but slow peripheral into a high-performance, set-and-forget telemetry bridge for the AirSense 11 ecosystem.Citations: